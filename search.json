[
  {
    "objectID": "runde_1/aufgabe_1/index.html",
    "href": "runde_1/aufgabe_1/index.html",
    "title": "1. Aufgabe: Störung",
    "section": "",
    "text": "NoteDie Aufgabe\n\n\n\nAlice und Bob tauschen in ihrem persönlichen Chat gerne Sätze aus, die Zitate aus ihrem Lieblingsbuch sind. Leider hat Trudi einen Weg gefunden, Lücken in die Sätze zu reißen und ganze Wörter verschwinden zu lassen. So empfing Bob vor Kurzem diesen Lückensatz von Alice, den er nicht verstehen konnte:\ndas ... mir ... ... ... vor\nEr musste lange im Buch blättern, bis er diese passende Stelle darin fand:\ndas kommt mir gar nicht richtig vor\nAber er ist unsicher, denn schließlich könnte es ja noch andere passende Stellen geben. Alice und Bob überlegen, wie sie das Problem lösen können. Den Text des Lieblingsbuches gibt es auch digital. Da könnte es doch möglich sein, sich die Suche nach passenden Stellen von einem Computerprogramm abnehmen zu lassen."
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#unser-ansatz-textmustersuche-mit-regulären-ausdrücken",
    "href": "runde_1/aufgabe_1/index.html#unser-ansatz-textmustersuche-mit-regulären-ausdrücken",
    "title": "1. Aufgabe: Störung",
    "section": "Unser Ansatz: Textmustersuche mit Regulären Ausdrücken",
    "text": "Unser Ansatz: Textmustersuche mit Regulären Ausdrücken\nDas Problem, das Alice und Bob haben, ist ein klassisches Mustererkennungsproblem: Wie findet man einen Teilsatz, bei dem nur einige Wörter bekannt sind, während andere Wörter fehlen?\nFür die Lösung bietet sich die Verwendung von regulären Ausdrücken (Regular Expressions, kurz RegEx) an. Mit RegEx können wir flexible Muster definieren, die genau unserem Problem entsprechen:\n\nBekannte Wörter bleiben unverändert im Suchmuster\nLücken (fehlende Wörter) werden durch einen Platzhalter ersetzt, der “irgendein Wort” repräsentiert\nDie Reihenfolge der Wörter bleibt erhalten\n\n\nDie Hauptschritte des Algorithmus:\n\nEingabe lesen: Wir lesen die “gestörten” Sätze aus den Dateien\nMuster erstellen: Wir erstellen ein RegEx-Muster, das bekannte Wörter und Lücken enthält\nSuche durchführen: Wir durchsuchen den Text nach passenden Stellen\nErgebnisse anzeigen: Wir zeigen die gefundenen kompletten Sätze an"
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#dateien",
    "href": "runde_1/aufgabe_1/index.html#dateien",
    "title": "1. Aufgabe: Störung",
    "section": "Dateien",
    "text": "Dateien\n\n\nAlice_im_Wunderland.txt\nstoerung0.txt\nstoerung1.txt\nstoerung2.txt\nstoerung3.txt\nstoerung4.txt\nstoerung5.txt\n\n\n\n\n\n\n\n\nTip\n\n\n\nDie Dateien stoerung0.txt bis stoerung5.txt enthalten die lückenhaften Sätze, wobei _ für ein fehlendes Wort steht. Die Datei Alice_im_Wunderland.txt enthält den vollständigen Text des Buches."
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#implementierung-der-lösung",
    "href": "runde_1/aufgabe_1/index.html#implementierung-der-lösung",
    "title": "1. Aufgabe: Störung",
    "section": "Implementierung der Lösung",
    "text": "Implementierung der Lösung\nUnsere Implementierung verwendet die re-Bibliothek in Python, um reguläre Ausdrücke zu verarbeiten:\n\n# Regex-Muster für ein beliebiges Wort\nword_pattern = \"([a-z])\\\\w+\"\n\n# Für jede Lücke (_) verwenden wir das Wort-Muster\n# Für bekannte Wörter verwenden wir den exakten Text"
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#lösung",
    "href": "runde_1/aufgabe_1/index.html#lösung",
    "title": "1. Aufgabe: Störung",
    "section": "Lösung",
    "text": "Lösung\n\n\nCode\nimport re\n\nquestions: list[str] = []\nfor i in range(0, 6):\n    file_name = \"files/stoerung\" + str(i) + \".txt\"\n    with open(file_name) as f:\n        questions.append(f.read())\n\nbase_text = \"\"\nwith open(\"files/Alice_im_Wunderland.txt\") as b:\n    base_text = b.read().lower()\n\nfor i, question in enumerate(questions):\n    parts = question.split(\" \")\n    regex_parts = []\n\n    for part in parts:\n        if part == \"_\":\n            regex_parts.append(\"([a-z])\\\\w+\")\n        else:\n            regex_parts.append(part)\n\n    regex = \" \".join(regex_parts)\n\n    matches = re.search(regex, base_text, re.IGNORECASE)\n    if matches is None:\n        print(\"No match found for:\", regex)\n        continue\n\n    m = matches.group(0).split(\" \")\n    print(f\"Lösung zu Störung {i}\\n\")\n    print(f\"\\n\\n**Lückensatz:** `{question}`\\n\")\n    print(f\"**Vollständiger Satz:**\")\n\n    result = []\n    for j, part in enumerate(parts):\n        if part != \"_\":\n            result.append(part)\n        else:\n            result.append(f\"**{m[j]}**\")\n\n    print(f\"`{' '.join(result)}`\")\n    print(\"\\n\\n&lt;br&gt;&lt;br&gt;\")\n\nLösung zu Störung 0\nLückensatz: das _ mir _ _ _ vor\nVollständiger Satz: das **kommt** mir **gar** **nicht** **richtig** vor\n Lösung zu Störung 1\nLückensatz: ich muß _ clara _\nVollständiger Satz: ich muß **in** clara **verwandelt**\n Lösung zu Störung 2\nLückensatz: fressen _ gern _\nVollständiger Satz: fressen **katzen** gern **spatzen**\n Lösung zu Störung 3\nLückensatz: das _ fing _\nVollständiger Satz: das **spiel** fing **an**\n Lösung zu Störung 4\nLückensatz: ein _ _ tag\nVollständiger Satz: ein **sehr** **schöner** tag\n Lösung zu Störung 5\nLückensatz: wollen _ so _ sein\nVollständiger Satz: wollen **sie** so **gut** sein"
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#diskussion-des-ansatzes",
    "href": "runde_1/aufgabe_1/index.html#diskussion-des-ansatzes",
    "title": "1. Aufgabe: Störung",
    "section": "Diskussion des Ansatzes",
    "text": "Diskussion des Ansatzes\nDiese Methode hat einige interessante Eigenschaften:\n\nFlexibilität: Der Ansatz funktioniert für beliebig viele Lücken in einem Satz\nEffizienz: Reguläre Ausdrücke sind für Textsuche optimiert und arbeiten sehr schnell\nGrenzen: Es kann zu falschen Treffern kommen, wenn die vorhandenen Wörter nicht eindeutig genug sind\n\nFür eine erweiterte Lösung könnte man:\n\nKontextinformationen berücksichtigen (z.B. Kapitel oder Abschnitte)\nMehrere mögliche Treffer anzeigen und bewerten\nSprachmodelle einsetzen, um die wahrscheinlichste Vervollständigung zu finden"
  },
  {
    "objectID": "runde_1/aufgabe_3/index.html",
    "href": "runde_1/aufgabe_3/index.html",
    "title": "3. Aufgabe: Sudokopie",
    "section": "",
    "text": "NoteDie Aufgabe\n\n\n\nRudi ist gar nicht mehr begeistert von den Sudokus seiner Rätselzeitung: Er hat den starken Verdacht, dass die Redaktion die Sudoku-Aufgaben immer wiederverwendet! Die Rätsel sehen zwar unterschiedlich aus, aber der Lösungsweg wiederholt sich erkennbar. Er möchte nun seinen Verdacht nachweisen. Rudi überlegt sich, dass man aus einem Sudoku sehr viele Varianten erzeugen kann, indem man eine oder mehrere der folgenden Umformungen durchführt:\n\nPermutation (Umordnung) der drei Spalten innerhalb der Spaltenblöcke.\nPermutation der drei Spaltenblöcke.\nPermutation der drei Zeilen innerhalb der Zeilenblöcke.\nPermutation der drei Zeilenblöcke.\n90-Grad-Rotation im Uhrzeigersinn.\nUmbenennen der Ziffern 1 bis 9 (z.B. alle ‚8‘en und ‚3‘en vertauschen).\n\nSo sind zum Beispiel diese beiden Rätsel Varianten voneinander:\n Hierbei wurden der 1. und der 3. Spaltenblock sowie die 5. und die 6. Zeile vertauscht und die Ziffern wie folgt umbenannt: 1 → 2, 2 → 3, … , 8 → 9, 9 → 1."
  },
  {
    "objectID": "runde_1/aufgabe_3/index.html#lösungsansatz",
    "href": "runde_1/aufgabe_3/index.html#lösungsansatz",
    "title": "3. Aufgabe: Sudokopie",
    "section": "Lösungsansatz",
    "text": "Lösungsansatz\nDie Lösung zu diesem Problem ist etwas länger geworden, der gesamte Code ist hier. Grundsätzlich funktioniert der Algorithmus wie folgt:\n\nÜberblick\nDer Algorithmus verwendet einen systematischen Backtracking-Ansatz, um die Transformation eines Sudoku-Rätsels in ein anderes zu ermitteln. Der Prozess ist in der solve_sudoku_transformation-Funktion implementiert und läuft in drei aufeinanderfolgenden Phasen ab:\npub fn solve_sudoku_transformation(first: Sudoku, second: &Sudoku) -&gt; Option&lt;Vec&lt;Operation&gt;&gt; {\n    let mut curr_grid = first;\n    let mut operations = None;\n    for i in 0..4 {\n        let out = start_backtracking(\n            curr_grid.clone(),\n            second,\n            AlgorithmStage::SwapBlocks,\n            vec![Operation::Rotate(i)],\n        );\n        if out.is_some() {\n            operations = out;\n            break; // Found a solution\n        }\n\n        curr_grid = Sudoku::new(rotate_sudoku(&curr_grid.grid));\n    }\n\n    operations\n}\nDie Hauptarbeit wird in der rekursiven start_backtracking-Funktion erledigt, die durch die verschiedenen Phasen navigiert:\n\n\nDie drei Phasen des Algorithmus\n\nBlockwechsel-Phase: Zuerst werden Operationen ausprobiert, die ganze Blöcke (3×3 Zeilen oder Spalten) miteinander vertauschen. Der Algorithmus analysiert die Verteilung der Zahlen in den Blöcken, indem er zählt, wie viele Zellen in jedem Block besetzt sind. Diese Häufigkeitsverteilung dient als eine Art “Fingerabdruck” für jeden Block, wodurch der Algorithmus effizient bestimmen kann, welche Blöcke potentiell vertauscht werden müssen. Wenn beide Sudokus bereits die gleiche Verteilung von besetzten Zellen in ihren Blöcken haben, generiert der Algorithmus alle möglichen Kombinationen von Blockvertauschungen mit Hilfe der Powerset-Methode:\n\n// Code zum Zählen der besetzten Zellen in jedem Block\nlet f_col_counts = get_filled_block(&first, BlockType::Column);\nlet f_row_counts = get_filled_block(&first, BlockType::Row);\n\nif are_vec_same(&f_col_counts, &s_col_counts)\n    && are_vec_same(&f_row_counts, &s_row_counts)\n{\n    let col_swaps = possible_same_block_swaps(BlockType::Column, &f_col_counts);\n    let row_swaps = possible_same_block_swaps(BlockType::Row, &f_row_counts);\n\n    // Alle möglichen Kombinationen von Blockvertauschungen erzeugen\n    let powerset = col_swaps\n        .into_iter()\n        .interleave(row_swaps.into_iter())\n        .powerset()\n        .collect_vec();\n        \n    for ops in powerset {\n        let mut clone = first.clone();\n        // Alle Operationen in dieser Kombination anwenden\n        for o in &ops {\n            o.apply(&mut clone);\n        }\n        // ...\n    }\n}\n// Wenn nötig, spezifische Blockvertauschungen durchführen\nlet col_needed = needed_block_swaps(BlockType::Column, &f_col_counts, &s_col_counts);\nfor op in col_needed {\n    let mut clone = first.clone();\n    op.apply(&mut clone);\n    // ...\n}\nDie needed_block_swaps-Funktion erzeugt die notwendigen Operationen, um die Blockstruktur zwischen beiden Sudokus anzugleichen.\n\nEinzelwechsel-Phase: Nach dem Vertauschen ganzer Blöcke werden einzelne Zeilen oder Spalten innerhalb der Blöcke vertauscht. Dies geschieht systematisch durch das Erzeugen aller möglichen Kombinationen von Vertauschungen mit Hilfe von Permutationen:\n\nlet col_swaps = possible_same_single_swaps(BlockType::Column, &f_col_counts);\nlet rol_swaps = possible_same_single_swaps(BlockType::Row, &f_row_counts);\n\n// Alle möglichen Kombinationen von Zeilenvertauschungen testen\nlet powerset = col_swaps\n    .into_iter()\n    .interleave(rol_swaps.into_iter())\n    .powerset()\n    .collect_vec();\n\nfor ops in powerset {\n    let mut clone = first.clone();\n    // ...\n}\nDiese Phase ist in der SwapSingle-Stufe des Backtracking-Algorithmus implementiert.\n\nZiffernumbenennung-Phase: In der letzten Phase werden, falls nötig, Ziffern umbenannt. Der Algorithmus prüft systematisch, welche Zahlen noch nicht übereinstimmen und generiert entsprechende Umbenennungsoperationen:\n\n// Finden von Ziffern, die umbenannt werden müssen\nfor (y, row) in rows.iter().enumerate() {\n    for (x, numb) in row.iter().enumerate() {\n        let desired = &second.grid[(y, x)];\n        if numb == desired || numb == &0 || desired == &0 {\n            continue; // Bereits übereinstimmend oder leer\n        }\n        \n        change_from = Some(*numb);\n        change_to = Some(*desired);\n        // ...\n    }\n}\n\n// Anwenden der Ziffernumbenennung\nlet op = Operation::SwapNumbers(from, to);\nop.apply(&mut clone);\nDiese Phase ist in der SwapNumbers-Stufe implementiert.\n\n\nRotationen und Gesamtstrategie\nVor Beginn des Hauptprozesses werden alle vier möglichen 90-Grad-Rotationen (0°, 90°, 180°, 270°) des ersten Sudokus betrachtet. Für jede Rotation wird der komplette dreistufige Prozess durchgeführt:\nfor i in 0..4 {\n    let out = start_backtracking(\n        curr_grid.clone(),\n        second,\n        AlgorithmStage::SwapBlocks,\n        vec![Operation::Rotate(i)],\n    );\n    // ...\n    curr_grid = Sudoku::new(rotate_sudoku(&curr_grid.grid));\n}\nDer Algorithmus verfolgt eine “Teile-und-Herrsche”-Strategie und führt für jede Phase einen rekursiven Backtracking-Ansatz durch. Dies erlaubt es, den riesigen Suchraum aller möglichen Transformationen effizient zu durchsuchen. Die Operation-Enum repräsentiert alle möglichen Transformationen:\npub enum Operation {\n    SwapBlock(BlockType, usize, usize),\n    SwapSingle(BlockType, usize, usize),\n    SwapSpecial(BlockType, (usize, usize), (usize, usize)),\n    SwapNumbers(u8, u8),\n    Rotate(u8)\n}\nSobald eine Folge von Operationen gefunden wird, die das erste Sudoku in das zweite transformiert, wird diese als Lösung zurückgegeben und in benutzerfreundliche Meldungen formatiert:\n// Formatierung der Ergebnisse\npub fn format_operations(operations: &[Operation]) -&gt; Vec&lt;String&gt; {\n    let mut result = Vec::new();\n    for op in operations {\n        match op {\n            Operation::SwapBlock(block_type, a, b) =&gt; {\n                result.push(format!(\n                    \"Swap {:?} block {} with block {}\",\n                    block_type, a, b\n                ));\n            }\n            // Weitere Formate...\n        }\n    }\n    result\n}\nFalls keine Transformation existiert, die das erste Sudoku in das zweite überführt, wird dies ebenfalls erkannt und entsprechend gemeldet."
  },
  {
    "objectID": "runde_1/aufgabe_3/index.html#lösungen",
    "href": "runde_1/aufgabe_3/index.html#lösungen",
    "title": "3. Aufgabe: Sudokopie",
    "section": "Lösungen",
    "text": "Lösungen\nIm Folgenden sind die Ergebnisse für verschiedene Testfälle aufgeführt. Die Ausgaben zeigen die Sequenz von Operationen, die nötig sind, um das erste Sudoku in das zweite zu transformieren.\n\nSudoku 0\nFür dieses Sudoku-Paar sind folgende Transformationen nötig:\n\nSpaltenoperationen:\n\nVertauschen der Spaltenblöcke (3,5) und (4,5)\nVertauschen der einzelnen Spalten 0 mit 1, dann 0 mit 2, und 6 mit 8\n\nZeilenoperationen:\n\nVertauschen der einzelnen Zeilen 0 mit 1 und 7 mit 8\n\n\n\n\nSudoku 1\nDieses Sudoku-Paar erfordert eine Kombination aus Rotation und Vertauschungen:\n\nRotation: 90 Grad im Uhrzeigersinn\nBlockoperationen:\n\nSpaltenblock 0 mit Block 1 vertauschen\nZeilenblock 0 mit Block 1 vertauschen\nZeilenblock 1 mit Block 2 vertauschen\n\nEinzelne Spalten: Vertauschen der Spalten 0 mit 2, 3 mit 5, und 6 mit 8\n\n\n\nSudoku 2\nBei diesem Paar ist eine komplexere Transformation mit Blockvertauschungen, Zeilenvertauschungen und mehreren Ziffernumbennungen erforderlich:\n\nBlockoperationen: Spaltenblock 0 mit Block 2 vertauschen\nZeilenoperationen: Vertauschen der Zeilen 4 und 5\nZiffernumbenennung: Eine Reihe von Ziffernvertauschungen:\n\n4 ↔︎ 5\n9 ↔︎ 1\n8 ↔︎ 9\n4 ↔︎ 6\n3 ↔︎ 4\n8 ↔︎ 2\n3 ↔︎ 7\n3 ↔︎ 8\n\n\n\n\nSudoku 3\nFür dieses Sudoku-Paar wurde keine Lösung gefunden. Dies bedeutet, dass die beiden Sudokus keine Varianten voneinander sind und nicht durch die erlaubten Transformationen ineinander überführt werden können.\n\n\nSudoku 4\nDies ist das komplexeste Beispiel mit einer Vielzahl von Transformationen:\n\nRotation: 90 Grad im Uhrzeigersinn\nBlockoperationen:\n\nSpaltenblock 0 mit Block 1 vertauschen\nZeilenblock 1 mit Block 2 vertauschen\n\nEinzeloperationen:\n\nSpalten 4 mit 5 und 7 mit 8 vertauschen\nZeilen 0 mit 2, 3 mit 5, und 6 mit 8 vertauschen\n\nZiffernumbenennung:\n\n4 ↔︎ 9\n8 ↔︎ 3\n5 ↔︎ 2\n8 ↔︎ 1\n4 ↔︎ 6\n5 ↔︎ 8\n5 ↔︎ 4\n\n\nDiese Ergebnisse zeigen die Vielfalt der möglichen Transformationen. Während für die Sudokus 0, 1, 2 und 4 Transformationen gefunden wurden, gibt es für Sudoku 3 keine Möglichkeit, die beiden Rätsel ineinander zu überführen. Dies bestätigt, dass nicht alle Sudoku-Rätsel Varianten voneinander sein müssen."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bundeswettbewerb Informatik 2023",
    "section": "",
    "text": "Willkommen zu meiner Dokumentation der Lösungen für den Bundeswettbewerb Informatik 2023. In diesem Quarto-Projekt präsentiere ich meine Herangehensweisen, Lösungsstrategien und Implementierungen für die verschiedenen Aufgaben des Wettbewerbs. Der Bundeswettbewerb Informatik ist einer der renommiertesten Informatikwettbewerbe für Schülerinnen und Schüler in Deutschland und bietet eine hervorragende Gelegenheit, praktische Programmierfähigkeiten und algorithmisches Denken zu demonstrieren.\nDieses Projekt dient nicht nur als Dokumentation meiner Lösungen, sondern soll auch anderen Teilnehmenden und Interessierten als Inspirationsquelle und Lernmaterial dienen. Ich habe mich für Quarto als Plattform entschieden, da es die nahtlose Integration von Code, Erklärungen und Visualisierungen ermöglicht."
  },
  {
    "objectID": "index.html#einleitung",
    "href": "index.html#einleitung",
    "title": "Bundeswettbewerb Informatik 2023",
    "section": "",
    "text": "Willkommen zu meiner Dokumentation der Lösungen für den Bundeswettbewerb Informatik 2023. In diesem Quarto-Projekt präsentiere ich meine Herangehensweisen, Lösungsstrategien und Implementierungen für die verschiedenen Aufgaben des Wettbewerbs. Der Bundeswettbewerb Informatik ist einer der renommiertesten Informatikwettbewerbe für Schülerinnen und Schüler in Deutschland und bietet eine hervorragende Gelegenheit, praktische Programmierfähigkeiten und algorithmisches Denken zu demonstrieren.\nDieses Projekt dient nicht nur als Dokumentation meiner Lösungen, sondern soll auch anderen Teilnehmenden und Interessierten als Inspirationsquelle und Lernmaterial dienen. Ich habe mich für Quarto als Plattform entschieden, da es die nahtlose Integration von Code, Erklärungen und Visualisierungen ermöglicht."
  },
  {
    "objectID": "index.html#überblick-über-die-runden",
    "href": "index.html#überblick-über-die-runden",
    "title": "Bundeswettbewerb Informatik 2023",
    "section": "Überblick über die Runden",
    "text": "Überblick über die Runden\nDer Bundeswettbewerb Informatik gliedert sich in drei aufeinander aufbauende Runden, die unterschiedliche Anforderungen an die Teilnehmenden stellen:\n\n1. Runde\nDie erste Runde ist für alle Interessierten offen und besteht aus mehreren Programmieraufgaben, die innerhalb eines bestimmten Zeitraums zu lösen sind. Die Aufgaben decken unterschiedliche Bereiche der Informatik ab und erfordern sowohl theoretisches Verständnis als auch praktische Programmierfähigkeiten.\nIn der ersten Runde habe ich folgende Aufgaben bearbeitet:\n\nAufgabe 1: Störung - Textanalyse und -rekonstruktion\nAufgabe 2: Verzinkt\nAufgabe 3: Sudokopie\n\n\n\n2. Runde\nDie zweite Runde ist anspruchsvoller und richtet sich an diejenigen, die in der ersten Runde erfolgreich waren. Hier werden komplexere Probleme gestellt, die tieferes algorithmisches Verständnis und fortgeschrittene Programmierkenntnisse erfordern.\nIn der zweiten Runde habe ich mich mit diesen Aufgaben befasst:\n\nAufgabe 1: [Kurzbeschreibung der Aufgabe]\nAufgabe 2: [Kurzbeschreibung der Aufgabe]\n\n\n\n3. Runde (Endrunde)\nDie dritte Runde ist die Endrunde, zu der nur die besten Teilnehmenden eingeladen werden. Sie findet in Form eines mehrtägigen Workshops statt, bei dem die Finalisten anspruchsvolle Aufgaben lösen und ihre Lösungen vor einer Jury präsentieren müssen.\nIn der Endrunde werden sowohl Einzelaufgaben als auch Gruppenarbeiten durchgeführt, die umfassende Kenntnisse in verschiedenen Bereichen der Informatik erfordern:\n\nTheoretische Informatik\nAlgorithmen und Datenstrukturen\nSoftwareentwicklung\nProblemlösung unter Zeitdruck"
  },
  {
    "objectID": "runde_1/index.html",
    "href": "runde_1/index.html",
    "title": "1. Runde - Bundeswettbewerb Informatik 2023/2024",
    "section": "",
    "text": "Die erste Runde des 41. Bundeswettbewerbs Informatik bietet fünf spannende Aufgaben, aus denen Teilnehmer drei auswählen und bearbeiten können. Auf dieser Seite gebe ich einen Überblick über die Aufgaben und meine Lösungsansätze.\n\n\n\n\n\n\nNoteDie 1. Runde im Überblick\n\n\n\n\nZeitraum: September 2023 bis November 2023\nAufgabenstellung: 5 Aufgaben, davon 3 zu bearbeiten\nEinreichung: Dokumentation und lauffähiger Programmcode\nBearbeitung: Einzeln oder im Team (max. 3 Personen)\n\n\n\n\n\nDer Bundeswettbewerb Informatik ist ein anspruchsvoller Programmierwettbewerb für Schülerinnen und Schüler. Er fördert die kreative Auseinandersetzung mit algorithmischen Problemen und die Entwicklung effizienter Lösungsstrategien. Der Wettbewerb wird vom Bundesministerium für Bildung und Forschung gefördert und richtet sich an Jugendliche bis 21 Jahre.\nDie 41. Ausgabe des Wettbewerbs startete im September 2023 mit der ersten Runde, in der die Teilnehmer fünf anspruchsvolle Aufgaben zur Auswahl haben, von denen drei zu bearbeiten sind.\n\n\n\n\n\n\n\n\nTextanalyse (Quelle: 41. Bundeswettbewerb der Informatik)\n\n\nBei dieser Aufgabe geht es um Textmustersuche: Alice und Bob haben das Problem, dass in ihrem Chat Nachrichten mit Lücken ankommen. Die Herausforderung besteht darin, ein Programm zu entwickeln, das im digitalen Text ihres Lieblingsbuches nach passenden Stellen sucht, um die Lücken zu füllen.\nMein Ansatz: Ich habe reguläre Ausdrücke (RegEx) verwendet, um Muster mit Lücken zu definieren und den Text effizient zu durchsuchen. Das Programm kann mehrere mögliche Übereinstimmungen finden und nach verschiedenen Kriterien sortieren.\nZur vollständigen Lösung →\n\n\n\n\n\n\nBeispielbild\n\n\nDiese Aufgabe beschäftigt sich mit der Simulation von Kristallwachstum, wie es bei feuerverzinkten Metallen zu beobachten ist. Kristalle wachsen von zufälligen Keimen aus und breiten sich aus, bis sie auf andere Kristalle treffen.\nMein Ansatz: Ich habe einen Algorithmus entwickelt, der das Wachstum von Kristallen simuliert, indem er: 1. Zufällige Kristallisationskeime platziert 2. Das Wachstum der Kristalle mit gewichteten Wahrscheinlichkeiten für verschiedene Richtungen simuliert 3. Die entstehenden Muster visualisiert\nZur vollständigen Lösung →\n\n\n\nBei dieser Aufgabe geht es um eine Variante des klassischen Sudoku-Puzzles. Sudokopie beschäftigt sich mit der Frage, ob ein Sudoku-Rätsel eindeutig lösbar ist oder ob es mehrere gültige Lösungen haben kann. Die Herausforderung besteht darin, ein Programm zu entwickeln, das prüft, ob ein Sudoku-Rätsel eine eindeutige Lösung hat oder ob es durch “Kopieren” bestimmter Zellen zu mehreren Lösungen führen kann.\nZur vollständigen Lösung →\n\n\n\n\nBei der Bearbeitung der Aufgaben bin ich nach folgendem Schema vorgegangen:\n\nProblemanalyse: Sorgfältiges Studium der Aufgabenstellung und Identifikation der Kernprobleme\nKonzeptentwicklung: Skizzierung verschiedener Lösungsansätze und Auswahl des vielversprechendsten\nImplementierung: Umsetzung des Lösungsansatzes in Code mit Fokus auf Korrektheit und Effizienz\nTesten und Optimieren: Überprüfung der Lösung mit verschiedenen Testfällen und Optimierung der Performance\nDokumentation: Ausführliche Dokumentation des Lösungswegs, der Algorithmen und der Implementierung\n\nDie detaillierten Lösungen und Code-Implementierungen sind auf den jeweiligen Aufgabenseiten zu finden.\n\n\n\nBei meinen Lösungen habe ich verschiedene Technologien und Werkzeuge eingesetzt:\n\nProgrammiersprachen: JavaScript/TypeScript, Python\nBibliotheken und Frameworks: ObservableJS, NumPy, Matplotlib\nEntwicklungsumgebung: Visual Studio Code\nDokumentation: Quarto für die Erstellung dieser interaktiven Webseite\n\n\n\n\nAufgrund meiner Erfahrung mit dem Wettbewerb möchte ich folgende Tipps für andere Teilnehmer teilen:\n\nAufgaben gründlich lesen: Häufig stecken wichtige Hinweise in Nebensätzen oder Beispielen.\nKlein anfangen: Entwickle zuerst eine einfache Lösung, die funktioniert, und verbessere sie dann schrittweise.\nTesten, testen, testen: Erstelle eigene Testfälle, um deine Lösung zu überprüfen.\nDokumentation nicht unterschätzen: Eine gut strukturierte und verständliche Dokumentation ist essenziell.\nZeit einplanen: Beginne frühzeitig, um genügend Zeit für Optimierungen und Problembehebung zu haben."
  },
  {
    "objectID": "runde_1/index.html#über-den-bundeswettbewerb-informatik",
    "href": "runde_1/index.html#über-den-bundeswettbewerb-informatik",
    "title": "1. Runde - Bundeswettbewerb Informatik 2023/2024",
    "section": "",
    "text": "Der Bundeswettbewerb Informatik ist ein anspruchsvoller Programmierwettbewerb für Schülerinnen und Schüler. Er fördert die kreative Auseinandersetzung mit algorithmischen Problemen und die Entwicklung effizienter Lösungsstrategien. Der Wettbewerb wird vom Bundesministerium für Bildung und Forschung gefördert und richtet sich an Jugendliche bis 21 Jahre.\nDie 41. Ausgabe des Wettbewerbs startete im September 2023 mit der ersten Runde, in der die Teilnehmer fünf anspruchsvolle Aufgaben zur Auswahl haben, von denen drei zu bearbeiten sind."
  },
  {
    "objectID": "runde_1/index.html#die-aufgaben-im-detail",
    "href": "runde_1/index.html#die-aufgaben-im-detail",
    "title": "1. Runde - Bundeswettbewerb Informatik 2023/2024",
    "section": "",
    "text": "Textanalyse (Quelle: 41. Bundeswettbewerb der Informatik)\n\n\nBei dieser Aufgabe geht es um Textmustersuche: Alice und Bob haben das Problem, dass in ihrem Chat Nachrichten mit Lücken ankommen. Die Herausforderung besteht darin, ein Programm zu entwickeln, das im digitalen Text ihres Lieblingsbuches nach passenden Stellen sucht, um die Lücken zu füllen.\nMein Ansatz: Ich habe reguläre Ausdrücke (RegEx) verwendet, um Muster mit Lücken zu definieren und den Text effizient zu durchsuchen. Das Programm kann mehrere mögliche Übereinstimmungen finden und nach verschiedenen Kriterien sortieren.\nZur vollständigen Lösung →\n\n\n\n\n\n\nBeispielbild\n\n\nDiese Aufgabe beschäftigt sich mit der Simulation von Kristallwachstum, wie es bei feuerverzinkten Metallen zu beobachten ist. Kristalle wachsen von zufälligen Keimen aus und breiten sich aus, bis sie auf andere Kristalle treffen.\nMein Ansatz: Ich habe einen Algorithmus entwickelt, der das Wachstum von Kristallen simuliert, indem er: 1. Zufällige Kristallisationskeime platziert 2. Das Wachstum der Kristalle mit gewichteten Wahrscheinlichkeiten für verschiedene Richtungen simuliert 3. Die entstehenden Muster visualisiert\nZur vollständigen Lösung →\n\n\n\nBei dieser Aufgabe geht es um eine Variante des klassischen Sudoku-Puzzles. Sudokopie beschäftigt sich mit der Frage, ob ein Sudoku-Rätsel eindeutig lösbar ist oder ob es mehrere gültige Lösungen haben kann. Die Herausforderung besteht darin, ein Programm zu entwickeln, das prüft, ob ein Sudoku-Rätsel eine eindeutige Lösung hat oder ob es durch “Kopieren” bestimmter Zellen zu mehreren Lösungen führen kann.\nZur vollständigen Lösung →"
  },
  {
    "objectID": "runde_1/index.html#mein-lösungsprozess",
    "href": "runde_1/index.html#mein-lösungsprozess",
    "title": "1. Runde - Bundeswettbewerb Informatik 2023/2024",
    "section": "",
    "text": "Bei der Bearbeitung der Aufgaben bin ich nach folgendem Schema vorgegangen:\n\nProblemanalyse: Sorgfältiges Studium der Aufgabenstellung und Identifikation der Kernprobleme\nKonzeptentwicklung: Skizzierung verschiedener Lösungsansätze und Auswahl des vielversprechendsten\nImplementierung: Umsetzung des Lösungsansatzes in Code mit Fokus auf Korrektheit und Effizienz\nTesten und Optimieren: Überprüfung der Lösung mit verschiedenen Testfällen und Optimierung der Performance\nDokumentation: Ausführliche Dokumentation des Lösungswegs, der Algorithmen und der Implementierung\n\nDie detaillierten Lösungen und Code-Implementierungen sind auf den jeweiligen Aufgabenseiten zu finden."
  },
  {
    "objectID": "runde_1/index.html#technologien-und-werkzeuge",
    "href": "runde_1/index.html#technologien-und-werkzeuge",
    "title": "1. Runde - Bundeswettbewerb Informatik 2023/2024",
    "section": "",
    "text": "Bei meinen Lösungen habe ich verschiedene Technologien und Werkzeuge eingesetzt:\n\nProgrammiersprachen: JavaScript/TypeScript, Python\nBibliotheken und Frameworks: ObservableJS, NumPy, Matplotlib\nEntwicklungsumgebung: Visual Studio Code\nDokumentation: Quarto für die Erstellung dieser interaktiven Webseite"
  },
  {
    "objectID": "runde_1/index.html#tipps-für-andere-teilnehmer",
    "href": "runde_1/index.html#tipps-für-andere-teilnehmer",
    "title": "1. Runde - Bundeswettbewerb Informatik 2023/2024",
    "section": "",
    "text": "Aufgrund meiner Erfahrung mit dem Wettbewerb möchte ich folgende Tipps für andere Teilnehmer teilen:\n\nAufgaben gründlich lesen: Häufig stecken wichtige Hinweise in Nebensätzen oder Beispielen.\nKlein anfangen: Entwickle zuerst eine einfache Lösung, die funktioniert, und verbessere sie dann schrittweise.\nTesten, testen, testen: Erstelle eigene Testfälle, um deine Lösung zu überprüfen.\nDokumentation nicht unterschätzen: Eine gut strukturierte und verständliche Dokumentation ist essenziell.\nZeit einplanen: Beginne frühzeitig, um genügend Zeit für Optimierungen und Problembehebung zu haben."
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html",
    "href": "runde_1/aufgabe_2/index.html",
    "title": "2. Aufgabe: Verzinkt",
    "section": "",
    "text": "NoteDie Aufgabe\n\n\n\n\n\nMuster wie im Bild unten sieht man an feuerverzinkten Metallen, zum Beispiel an den Masten von Laternen oder Ampeln. Diese Muster entstehen, indem sich beim Erkalten des flüssigen Zinks, von zufällig vorhandenen Kristallisationskeimen aus, Kristalle bilden. Jeder Keim hat eine bestimmte Orientierung. Um ihn herum wächst ein Kristall mit der gleichen Orientierung, bis er auf andere Kristalle trifft. Kristalle unterschiedlicher Orientierung reflektieren das Licht unterschiedlich und erscheinen so unterschiedlich hell.\n\n\n\n\nFeuerverzinktes Metall (Quelle: Wikipedia)"
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html#unser-ansatz-simulation-von-kristallwachstum",
    "href": "runde_1/aufgabe_2/index.html#unser-ansatz-simulation-von-kristallwachstum",
    "title": "2. Aufgabe: Verzinkt",
    "section": "Unser Ansatz: Simulation von Kristallwachstum",
    "text": "Unser Ansatz: Simulation von Kristallwachstum\nUm die einzigartigen Muster zu simulieren, die bei der Feuerverzinkung entstehen, verwenden wir einen Algorithmus, der das natürliche Wachstum von Kristallen nachahmt:\n\nZufällige Keimbildung: Wir starten mit einigen zufällig platzierten Kristallisationskeimen.\nGerichtetes Wachstum: Jeder Kristall wächst in eine zufällige Richtung mit einer Farbe.\nKonkurrenz um Raum: Kristalle wachsen, bis sie auf andere Kristalle treffen und dann stoppen.\nGewichtete Ausbreitung: Die Wachstumsrichtung kann durch Parameter gesteuert werden, um verschiedene Muster zu erzeugen.\n\n\nDie Hauptschritte des Algorithmus:\n\nInitialisierung: Platzieren einer konfigurierbaren Anzahl von Kristallisationskeimen mit zufälligen Positionen und Orientierungen.\nWachstum: Iteratives Ausbreiten der Kristalle in verschiedene Richtungen mit gewichteten Wahrscheinlichkeiten.\nRendering: Visualisierung der Kristalle auf einem Canvas, wobei verschiedene Orientierungen durch unterschiedliche Farben dargestellt werden."
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html#implementierung-der-lösung",
    "href": "runde_1/aufgabe_2/index.html#implementierung-der-lösung",
    "title": "2. Aufgabe: Verzinkt",
    "section": "Implementierung der Lösung",
    "text": "Implementierung der Lösung\nUnsere Implementierung verwendet ObservableJS, um eine interaktive Visualisierung zu erstellen. Der Kern des Algorithmus ist eine Funktion, die das Kristallwachstum simuliert:\n// Kristallwachstums-Simulation - Kernalgorithmus\nfunction crystalGrowth(parameters) {\n  // 1. Initialisierung der Kristallisationskeime\n  // 2. Wachstumsschleife mit gewichteten Richtungen\n  // 3. Rendering auf Canvas\n}\nDie Simulation verwendet folgende Schlüsselkonzepte:\n\nGewichtete Richtungen: Jede der acht möglichen Wachstumsrichtungen (links, rechts, oben, unten und diagonal) kann individuell gewichtet werden.\nZufällige Kristallbildung: Neue Kristalle können während der Simulation mit einer kleinen Wahrscheinlichkeit entstehen.\nEffiziente Datenstrukturen: Für die Verfolgung besetzter Positionen und aktiver Wachstumspunkte werden optimierte Datenstrukturen verwendet."
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html#interaktive-visualisierung",
    "href": "runde_1/aufgabe_2/index.html#interaktive-visualisierung",
    "title": "2. Aufgabe: Verzinkt",
    "section": "Interaktive Visualisierung",
    "text": "Interaktive Visualisierung\n\n\nCode\nviewof wNegX = Inputs.range([0, 1], {step: 0.01, value: 0.1, label: \"Weight Left\"})\nviewof wNegY = Inputs.range([0, 1], {step: 0.01, value: 0.4, label: \"Weight Down\"})\nviewof wPosX = Inputs.range([0, 1], {step: 0.01, value: 0.1, label: \"Weight Right\"})\nviewof wPosY = Inputs.range([0, 1], {step: 0.01, value: 0.1, label: \"Weight Up\"})\n\nviewof wNegXNegY = Inputs.range([0, 1], {step: 0.01, value: 0.05, label: \"Weight Top-Left\"})\nviewof wNegXPosY = Inputs.range([0, 1], {step: 0.01, value: 0.05, label: \"Weight Bottom-Left\"})\nviewof wPosXNegY = Inputs.range([0, 1], {step: 0.01, value: 0.05, label: \"Weight Top-Right\"})\nviewof wPosXPosY = Inputs.range([0, 1], {step: 0.01, value: 0.05, label: \"Weight Bottom-Right\"})\n\nviewof startCrystals = Inputs.range([1, 200], {step: 1, value: 50, label: \"Starting Crystals\"})\nviewof pNewCrystal = Inputs.range([0, 0.01], {step: 0.0001, value: 0.001, label: \"New Crystal Probability\"})\n\nviewof canvasSize = Inputs.range([64, 512], {step: 64, value: 256, label: \"Canvas Size\"})\n\n// Helper functions for coordinate conversion\nfunction coordsToIndex(x, y, width) {\n  return y * width + x;\n}\n\nfunction indexToCoords(index, width) {\n  return {\n    x: index % width,\n    y: Math.floor(index / width)\n  };\n}\n\n// Initialize crystal simulation data structures\nfunction initializeSimulation(width, height, startCrystals) {\n    // Initialize data array with nulls\n    const data = Array(width * height).fill(null);\n\n    // Use a Set to track occupied positions for faster lookups\n    const occupiedPositions = new Set();\n    const growingPoints = [];\n\n    // Create initial crystals\n    for (let i = 0; i &lt; startCrystals; i++) {\n        let x, y, index;\n\n        // Ensure we don't place crystals on already occupied positions\n        do {\n        x = Math.floor(Math.random() * width);\n        y = Math.floor(Math.random() * height);\n        index = coordsToIndex(x, y, width);\n        } while (occupiedPositions.has(index));\n\n        const color = Math.random() * 255;\n        const crystal = { x, y, color };\n\n        data[index] = crystal;\n        occupiedPositions.add(index);\n        growingPoints.push(crystal);\n    }\n\n    return { data, occupiedPositions, growingPoints };\n}\n\n// Create direction vectors with weights\nfunction createDirections(wNegX, wNegY, wPosX, wPosY, wNegXNegY, wNegXPosY, wPosXNegY, wPosXPosY) {\n    return [\n        { dx: -1, dy: 0, w: wNegX },    // left\n        { dx: 1, dy: 0, w: wPosX },     // right\n        { dx: 0, dy: -1, w: wPosY },    // up\n        { dx: 0, dy: 1, w: wNegY },     // down\n        { dx: -1, dy: -1, w: wNegXNegY }, // top-left\n        { dx: -1, dy: 1, w: wNegXPosY },  // bottom-left\n        { dx: 1, dy: -1, w: wPosXNegY },  // top-right\n        { dx: 1, dy: 1, w: wPosXPosY }    // bottom-right\n    ];\n}\n\n// Attempt to create a new random crystal\nfunction tryCreateRandomCrystal(data, occupiedPositions, queue, width, height) {\n    for (let i = 0; i &lt; 100; i++) {\n        // Randomly select a position\n        const randomIndex = Math.floor(Math.random() * data.length);\n        if (occupiedPositions.has(randomIndex)) continue;\n\n        const { x: nX, y: nY } = indexToCoords(randomIndex, width);\n        const newCrystal = {\n        color: Math.random() * 255,\n        x: nX,\n        y: nY\n        };\n\n        // Update data structure\n        const index = coordsToIndex(nX, nY, width);\n        data[index] = newCrystal;\n        occupiedPositions.add(index);\n        queue.push(newCrystal);\n        return true;\n    }\n    return false;\n}\n\n// Process one crystal's growth\nfunction processCrystalGrowth(crystal, directions, data, occupiedPositions, queue, width, height) {\n    const { x, y, color } = crystal;\n\n    // Shuffle directions once per crystal\n    const shuffledDirs = [...directions].sort(() =&gt; Math.random() - 0.5);\n\n    let hasFound = false;\n    let hasSkipped = false;\n\n    for (const { dx, dy, w } of shuffledDirs) {\n        const nX = x + dx;\n        const nY = y + dy;\n\n        // Boundary check\n        if (nX &lt; 0 || nX &gt;= width || nY &lt; 0 || nY &gt;= height) {\n        continue;\n        }\n\n        const index = coordsToIndex(nX, nY, width);\n\n        // Check if position is already occupied\n        if (occupiedPositions.has(index)) {\n        continue;\n        }\n\n        if (Math.random() &gt; w) {\n        hasSkipped = true;\n        continue;\n        }\n\n        // Create new crystal\n        const newCrystal = { x: nX, y: nY, color };\n\n        // Update data structures\n        data[index] = newCrystal;\n        occupiedPositions.add(index);\n        queue.push(crystal);    // Add original crystal back to queue\n        queue.push(newCrystal); // Add new crystal to queue\n\n        hasFound = true;\n        break;\n    }\n\n    return { hasFound, hasSkipped };\n}\n\n// Render crystal data to canvas\nfunction renderCrystals(data, occupiedPositions, width, height) {\n    const canvas = DOM.canvas(width, height);\n    const ctx = canvas.getContext(\"2d\");\n\n    // Create image data\n    const imgData = ctx.createImageData(width, height);\n    const buffer = imgData.data;\n\n    // Fill with default color first (red for empty spaces)\n    for (let i = 0; i &lt; width * height; i++) {\n        const offset = i * 4;\n        buffer[offset] = 255;     // R\n        buffer[offset + 1] = 0;   // G\n        buffer[offset + 2] = 0;   // B\n        buffer[offset + 3] = 255; // A\n    }\n\n    // Only process occupied positions\n    for (const index of occupiedPositions) {\n        const crystal = data[index];\n        const color = crystal.color;\n        const shifted = Math.min(255, color + 10);\n\n        const offset = index * 4;\n        buffer[offset] = color;     // R\n        buffer[offset + 1] = shifted; // G\n        buffer[offset + 2] = shifted; // B\n        // Alpha already set to 255\n    }\n\n    ctx.putImageData(imgData, 0, 0);\n    return canvas;\n}\n\n// Main simulation function\nfunction crystalGrowth(wNegX, wNegY, wPosX, wPosY, wNegXNegY, wNegXPosY, wPosXNegY, wPosXPosY,\n                    startCrystals, pNewCrystal, canvasSize) {\n    // Canvas dimensions\n    const width = canvasSize;\n    const height = canvasSize;\n\n    // Initialize simulation\n    const { data, occupiedPositions, growingPoints } = initializeSimulation(width, height, startCrystals);\n\n    // Create direction vectors\n    const directions = createDirections(wNegX, wNegY, wPosX, wPosY, wNegXNegY, wNegXPosY, wPosXNegY, wPosXPosY);\n\n    // Process growing points using a queue\n    const queue = [...growingPoints];\n    growingPoints.length = 0; // Clear the original array\n\n    // Growth algorithm\n    while (queue.length &gt; 0 || data.some(crystal =&gt; crystal === null)) {\n        // Try to create a new random crystal\n        if (Math.random() &lt; pNewCrystal) {\n        if (tryCreateRandomCrystal(data, occupiedPositions, queue, width, height)) {\n            continue;\n        }\n        }\n\n        // No more crystals to grow\n        if (queue.length === 0) break;\n\n        // Get next crystal from queue\n        const crystal = queue.shift();\n\n        // Process this crystal's growth\n        const { hasFound, hasSkipped } = processCrystalGrowth(\n            crystal,\n            directions,\n            data,\n            occupiedPositions,\n            queue,\n            width,\n            height\n        );\n\n        // If we skipped some directions but didn't grow, give this crystal another chance later\n        if (!hasFound && hasSkipped) {\n        queue.push(crystal);\n        }\n    }\n\n    // Render the result\n    return renderCrystals(data, occupiedPositions, width, height);\n}\n\n// Run the simulation with the current parameter values\ncrystalGrowth(wNegX, wNegY, wPosX, wPosY, wNegXNegY, wNegXPosY, wPosXNegY, wPosXPosY,\n    startCrystals, pNewCrystal, canvasSize)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeneriertes Metall"
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html#diskussion-des-ansatzes",
    "href": "runde_1/aufgabe_2/index.html#diskussion-des-ansatzes",
    "title": "2. Aufgabe: Verzinkt",
    "section": "Diskussion des Ansatzes",
    "text": "Diskussion des Ansatzes\nDie implementierte Simulation ermöglicht es, die charakteristischen Muster von feuerverzinktem Metall realistisch nachzubilden. Unser Ansatz hat folgende Eigenschaften:\n\nInteraktivität: Durch die Steuerelemente können Benutzer verschiedene Parameter anpassen und unmittelbar die Auswirkungen auf das resultierende Muster beobachten.\nEffizienz: Die Verwendung optimierter Datenstrukturen ermöglicht eine flüssige Simulation auch bei größeren Canvas-Größen.\nRealismus: Die zufällige Keimbildung und das konkurrierende Wachstum der Kristalle ahmen die natürlichen Prozesse nach, die bei der Feuerverzinkung auftreten.\n\n\nMögliche Erweiterungen\nFür eine noch realistischere Simulation könnten folgende Aspekte hinzugefügt werden:\n\nTemperaturgradienten: Simulation der Abkühlung des Metalls, die die Kristallbildung beeinflusst\nMaterialverunreinigungen: Simulation von Störstellen, die das Wachstumsmuster beeinflussen\n3D-Visualisierung: Erweiterung auf eine dreidimensionale Darstellung für noch realistischere Ergebnisse\nPhysikalisch basierte Rendering-Techniken: Verbesserte Darstellung der Lichtreflexionen an den Kristalloberflächen"
  }
]