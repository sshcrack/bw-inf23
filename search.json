[
  {
    "objectID": "runde_1/aufgabe_1/index.html",
    "href": "runde_1/aufgabe_1/index.html",
    "title": "1. Aufgabe: Störung",
    "section": "",
    "text": "NoteDie Aufgabe\n\n\n\nAlice und Bob tauschen in ihrem persönlichen Chat gerne Sätze aus, die Zitate aus ihrem Lieblingsbuch sind. Leider hat Trudi einen Weg gefunden, Lücken in die Sätze zu reißen und ganze Wörter verschwinden zu lassen. So empfing Bob vor Kurzem diesen Lückensatz von Alice, den er nicht verstehen konnte:\ndas ... mir ... ... ... vor\nEr musste lange im Buch blättern, bis er diese passende Stelle darin fand:\ndas kommt mir gar nicht richtig vor\nAber er ist unsicher, denn schließlich könnte es ja noch andere passende Stellen geben. Alice und Bob überlegen, wie sie das Problem lösen können. Den Text des Lieblingsbuches gibt es auch digital. Da könnte es doch möglich sein, sich die Suche nach passenden Stellen von einem Computerprogramm abnehmen zu lassen."
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#unser-ansatz-textmustersuche-mit-regulären-ausdrücken",
    "href": "runde_1/aufgabe_1/index.html#unser-ansatz-textmustersuche-mit-regulären-ausdrücken",
    "title": "1. Aufgabe: Störung",
    "section": "Unser Ansatz: Textmustersuche mit Regulären Ausdrücken",
    "text": "Unser Ansatz: Textmustersuche mit Regulären Ausdrücken\nDas Problem, das Alice und Bob haben, ist ein klassisches Mustererkennungsproblem: Wie findet man einen Teilsatz, bei dem nur einige Wörter bekannt sind, während andere Wörter fehlen?\nFür die Lösung bietet sich die Verwendung von regulären Ausdrücken (Regular Expressions, kurz RegEx) an. Mit RegEx können wir flexible Muster definieren, die genau unserem Problem entsprechen:\n\nBekannte Wörter bleiben unverändert im Suchmuster\nLücken (fehlende Wörter) werden durch einen Platzhalter ersetzt, der “irgendein Wort” repräsentiert\nDie Reihenfolge der Wörter bleibt erhalten\n\n\nDie Hauptschritte des Algorithmus:\n\nEingabe lesen: Wir lesen die “gestörten” Sätze aus den Dateien\nMuster erstellen: Wir erstellen ein RegEx-Muster, das bekannte Wörter und Lücken enthält\nSuche durchführen: Wir durchsuchen den Text nach passenden Stellen\nErgebnisse anzeigen: Wir zeigen die gefundenen kompletten Sätze an"
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#dateien",
    "href": "runde_1/aufgabe_1/index.html#dateien",
    "title": "1. Aufgabe: Störung",
    "section": "Dateien",
    "text": "Dateien\n\n\nAlice_im_Wunderland.txt\nstoerung0.txt\nstoerung1.txt\nstoerung2.txt\nstoerung3.txt\nstoerung4.txt\nstoerung5.txt\n\n\n\n\n\n\n\n\nTip\n\n\n\nDie Dateien stoerung0.txt bis stoerung5.txt enthalten die lückenhaften Sätze, wobei _ für ein fehlendes Wort steht. Die Datei Alice_im_Wunderland.txt enthält den vollständigen Text des Buches."
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#implementierung-der-lösung",
    "href": "runde_1/aufgabe_1/index.html#implementierung-der-lösung",
    "title": "1. Aufgabe: Störung",
    "section": "Implementierung der Lösung",
    "text": "Implementierung der Lösung\nUnsere Implementierung verwendet die re-Bibliothek in Python, um reguläre Ausdrücke zu verarbeiten:\n\n# Regex-Muster für ein beliebiges Wort\nword_pattern = \"([a-z])\\\\w+\"\n\n# Für jede Lücke (_) verwenden wir das Wort-Muster\n# Für bekannte Wörter verwenden wir den exakten Text"
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#lösung",
    "href": "runde_1/aufgabe_1/index.html#lösung",
    "title": "1. Aufgabe: Störung",
    "section": "Lösung",
    "text": "Lösung\n\n\nCode\nimport re\n\nquestions: list[str] = []\nfor i in range(0, 6):\n    file_name = \"files/stoerung\" + str(i) + \".txt\"\n    f = open(file_name)\n    questions.append(f.read())\n\nbase_text = open(\"files/Alice_im_Wunderland.txt\").read().lower()\n\nfor i, question in enumerate(questions):\n    parts = question.split(\" \")\n    regex_parts = []\n\n    for part in parts:\n        if part == \"_\":\n            regex_parts.append(\"([a-z])\\\\w+\")\n        else:\n            regex_parts.append(part)\n\n    regex = \" \".join(regex_parts)\n\n    matches = re.search(regex, base_text, re.IGNORECASE)\n    if matches is None:\n        print(\"No match found for:\", regex)\n        continue\n\n    m = matches.group(0).split(\" \")\n    print(f\"Lösung zu Störung {i}\\n\")\n    print(f\"\\n\\n**Lückensatz:** `{question}`\\n\")\n    print(f\"**Vollständiger Satz:**\")\n\n    result = []\n    for j, part in enumerate(parts):\n        if part != \"_\":\n            result.append(part)\n        else:\n            result.append(f\"**{m[j]}**\")\n\n    print(f\"`{' '.join(result)}`\")\n    print(\"\\n\\n&lt;br&gt;&lt;br&gt;\")\n\nLösung zu Störung 0\nLückensatz: das _ mir _ _ _ vor\nVollständiger Satz: das **kommt** mir **gar** **nicht** **richtig** vor\n Lösung zu Störung 1\nLückensatz: ich muß _ clara _\nVollständiger Satz: ich muß **in** clara **verwandelt**\n Lösung zu Störung 2\nLückensatz: fressen _ gern _\nVollständiger Satz: fressen **katzen** gern **spatzen**\n Lösung zu Störung 3\nLückensatz: das _ fing _\nVollständiger Satz: das **spiel** fing **an**\n Lösung zu Störung 4\nLückensatz: ein _ _ tag\nVollständiger Satz: ein **sehr** **schöner** tag\n Lösung zu Störung 5\nLückensatz: wollen _ so _ sein\nVollständiger Satz: wollen **sie** so **gut** sein"
  },
  {
    "objectID": "runde_1/aufgabe_1/index.html#diskussion-des-ansatzes",
    "href": "runde_1/aufgabe_1/index.html#diskussion-des-ansatzes",
    "title": "1. Aufgabe: Störung",
    "section": "Diskussion des Ansatzes",
    "text": "Diskussion des Ansatzes\nDiese Methode hat einige interessante Eigenschaften:\n\nFlexibilität: Der Ansatz funktioniert für beliebig viele Lücken in einem Satz\nEffizienz: Reguläre Ausdrücke sind für Textsuche optimiert und arbeiten sehr schnell\nGrenzen: Es kann zu falschen Treffern kommen, wenn die vorhandenen Wörter nicht eindeutig genug sind\n\nFür eine erweiterte Lösung könnte man:\n\nKontextinformationen berücksichtigen (z.B. Kapitel oder Abschnitte)\nMehrere mögliche Treffer anzeigen und bewerten\nSprachmodelle einsetzen, um die wahrscheinlichste Vervollständigung zu finden"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bundeswettbewerb Informatik 2023",
    "section": "",
    "text": "Willkommen zu meiner Dokumentation der Lösungen für den Bundeswettbewerb Informatik 2023. In diesem Quarto-Projekt präsentiere ich meine Herangehensweisen, Lösungsstrategien und Implementierungen für die verschiedenen Aufgaben des Wettbewerbs. Der Bundeswettbewerb Informatik ist einer der renommiertesten Informatikwettbewerbe für Schülerinnen und Schüler in Deutschland und bietet eine hervorragende Gelegenheit, praktische Programmierfähigkeiten und algorithmisches Denken zu demonstrieren.\nDieses Projekt dient nicht nur als Dokumentation meiner Lösungen, sondern soll auch anderen Teilnehmenden und Interessierten als Inspirationsquelle und Lernmaterial dienen. Ich habe mich für Quarto als Plattform entschieden, da es die nahtlose Integration von Code, Erklärungen und Visualisierungen ermöglicht."
  },
  {
    "objectID": "index.html#einleitung",
    "href": "index.html#einleitung",
    "title": "Bundeswettbewerb Informatik 2023",
    "section": "",
    "text": "Willkommen zu meiner Dokumentation der Lösungen für den Bundeswettbewerb Informatik 2023. In diesem Quarto-Projekt präsentiere ich meine Herangehensweisen, Lösungsstrategien und Implementierungen für die verschiedenen Aufgaben des Wettbewerbs. Der Bundeswettbewerb Informatik ist einer der renommiertesten Informatikwettbewerbe für Schülerinnen und Schüler in Deutschland und bietet eine hervorragende Gelegenheit, praktische Programmierfähigkeiten und algorithmisches Denken zu demonstrieren.\nDieses Projekt dient nicht nur als Dokumentation meiner Lösungen, sondern soll auch anderen Teilnehmenden und Interessierten als Inspirationsquelle und Lernmaterial dienen. Ich habe mich für Quarto als Plattform entschieden, da es die nahtlose Integration von Code, Erklärungen und Visualisierungen ermöglicht."
  },
  {
    "objectID": "index.html#überblick-über-die-runden",
    "href": "index.html#überblick-über-die-runden",
    "title": "Bundeswettbewerb Informatik 2023",
    "section": "Überblick über die Runden",
    "text": "Überblick über die Runden\nDer Bundeswettbewerb Informatik gliedert sich in drei aufeinander aufbauende Runden, die unterschiedliche Anforderungen an die Teilnehmenden stellen:\n\n1. Runde\nDie erste Runde ist für alle Interessierten offen und besteht aus mehreren Programmieraufgaben, die innerhalb eines bestimmten Zeitraums zu lösen sind. Die Aufgaben decken unterschiedliche Bereiche der Informatik ab und erfordern sowohl theoretisches Verständnis als auch praktische Programmierfähigkeiten.\nIn der ersten Runde habe ich folgende Aufgaben bearbeitet:\n\nAufgabe 1: Störung - Textanalyse und -rekonstruktion\nAufgabe 2: Verzinkt\nAufgabe 3: Sudokopie\n\n\n\n2. Runde\nDie zweite Runde ist anspruchsvoller und richtet sich an diejenigen, die in der ersten Runde erfolgreich waren. Hier werden komplexere Probleme gestellt, die tieferes algorithmisches Verständnis und fortgeschrittene Programmierkenntnisse erfordern.\nIn der zweiten Runde habe ich mich mit diesen Aufgaben befasst:\n\nAufgabe 1: [Kurzbeschreibung der Aufgabe]\nAufgabe 2: [Kurzbeschreibung der Aufgabe]\n\n\n\n3. Runde (Endrunde)\nDie dritte Runde ist die Endrunde, zu der nur die besten Teilnehmenden eingeladen werden. Sie findet in Form eines mehrtägigen Workshops statt, bei dem die Finalisten anspruchsvolle Aufgaben lösen und ihre Lösungen vor einer Jury präsentieren müssen.\nIn der Endrunde werden sowohl Einzelaufgaben als auch Gruppenarbeiten durchgeführt, die umfassende Kenntnisse in verschiedenen Bereichen der Informatik erfordern:\n\nTheoretische Informatik\nAlgorithmen und Datenstrukturen\nSoftwareentwicklung\nProblemlösung unter Zeitdruck"
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html",
    "href": "runde_1/aufgabe_2/index.html",
    "title": "2. Aufgabe: Verzinkt",
    "section": "",
    "text": "NoteDie Aufgabe\n\n\n\n\n\nMuster wie im Bild unten sieht man an feuerverzinkten Metallen, zum Beispiel an den Masten von Laternen oder Ampeln. Diese Muster entstehen, indem sich beim Erkalten des flüssigen Zinks, von zufällig vorhandenen Kristallisationskeimen aus, Kristalle bilden. Jeder Keim hat eine bestimmte Orientierung. Um ihn herum wächst ein Kristall mit der gleichen Orientierung, bis er auf andere Kristalle trifft. Kristalle unterschiedlicher Orientierung reflektieren das Licht unterschiedlich und erscheinen so unterschiedlich hell.\n\n\n\n\nFeuerverzinktes Metall"
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html#unser-ansatz-simulation-von-kristallwachstum",
    "href": "runde_1/aufgabe_2/index.html#unser-ansatz-simulation-von-kristallwachstum",
    "title": "2. Aufgabe: Verzinkt",
    "section": "Unser Ansatz: Simulation von Kristallwachstum",
    "text": "Unser Ansatz: Simulation von Kristallwachstum\nUm die einzigartigen Muster zu simulieren, die bei der Feuerverzinkung entstehen, verwenden wir einen Algorithmus, der das natürliche Wachstum von Kristallen nachahmt:\n\nZufällige Keimbildung: Wir starten mit einigen zufällig platzierten Kristallisationskeimen.\nGerichtetes Wachstum: Jeder Kristall wächst in eine zufällige Richtung mit einer Farbe.\nKonkurrenz um Raum: Kristalle wachsen, bis sie auf andere Kristalle treffen und dann stoppen.\nGewichtete Ausbreitung: Die Wachstumsrichtung kann durch Parameter gesteuert werden, um verschiedene Muster zu erzeugen.\n\n\nDie Hauptschritte des Algorithmus:\n\nInitialisierung: Platzieren einer konfigurierbaren Anzahl von Kristallisationskeimen mit zufälligen Positionen und Orientierungen.\nWachstum: Iteratives Ausbreiten der Kristalle in verschiedene Richtungen mit gewichteten Wahrscheinlichkeiten.\nRendering: Visualisierung der Kristalle auf einem Canvas, wobei verschiedene Orientierungen durch unterschiedliche Farben dargestellt werden."
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html#implementierung-der-lösung",
    "href": "runde_1/aufgabe_2/index.html#implementierung-der-lösung",
    "title": "2. Aufgabe: Verzinkt",
    "section": "Implementierung der Lösung",
    "text": "Implementierung der Lösung\nUnsere Implementierung verwendet ObservableJS, um eine interaktive Visualisierung zu erstellen. Der Kern des Algorithmus ist eine Funktion, die das Kristallwachstum simuliert:\n// Kristallwachstums-Simulation - Kernalgorithmus\nfunction crystalGrowth(parameters) {\n  // 1. Initialisierung der Kristallisationskeime\n  // 2. Wachstumsschleife mit gewichteten Richtungen\n  // 3. Rendering auf Canvas\n}\nDie Simulation verwendet folgende Schlüsselkonzepte:\n\nGewichtete Richtungen: Jede der acht möglichen Wachstumsrichtungen (links, rechts, oben, unten und diagonal) kann individuell gewichtet werden.\nZufällige Kristallbildung: Neue Kristalle können während der Simulation mit einer kleinen Wahrscheinlichkeit entstehen.\nEffiziente Datenstrukturen: Für die Verfolgung besetzter Positionen und aktiver Wachstumspunkte werden optimierte Datenstrukturen verwendet."
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html#interaktive-visualisierung",
    "href": "runde_1/aufgabe_2/index.html#interaktive-visualisierung",
    "title": "2. Aufgabe: Verzinkt",
    "section": "Interaktive Visualisierung",
    "text": "Interaktive Visualisierung\n\n\nCode\nviewof wNegX = Inputs.range([0, 1], {step: 0.01, value: 0.1, label: \"Weight Left\"})\nviewof wNegY = Inputs.range([0, 1], {step: 0.01, value: 0.4, label: \"Weight Down\"})\nviewof wPosX = Inputs.range([0, 1], {step: 0.01, value: 0.1, label: \"Weight Right\"})\nviewof wPosY = Inputs.range([0, 1], {step: 0.01, value: 0.1, label: \"Weight Up\"})\n\nviewof wNegXNegY = Inputs.range([0, 1], {step: 0.01, value: 0.05, label: \"Weight Top-Left\"})\nviewof wNegXPosY = Inputs.range([0, 1], {step: 0.01, value: 0.05, label: \"Weight Bottom-Left\"})\nviewof wPosXNegY = Inputs.range([0, 1], {step: 0.01, value: 0.05, label: \"Weight Top-Right\"})\nviewof wPosXPosY = Inputs.range([0, 1], {step: 0.01, value: 0.05, label: \"Weight Bottom-Right\"})\n\nviewof startCrystals = Inputs.range([1, 200], {step: 1, value: 50, label: \"Starting Crystals\"})\nviewof pNewCrystal = Inputs.range([0, 0.01], {step: 0.0001, value: 0.001, label: \"New Crystal Probability\"})\n\nviewof canvasSize = Inputs.range([64, 512], {step: 64, value: 256, label: \"Canvas Size\"})\n\n// Helper functions for coordinate conversion\nfunction coordsToIndex(x, y, width) {\n  return y * width + x;\n}\n\nfunction indexToCoords(index, width) {\n  return {\n    x: index % width,\n    y: Math.floor(index / width)\n  };\n}\n\n// Initialize crystal simulation data structures\nfunction initializeSimulation(width, height, startCrystals) {\n    // Initialize data array with nulls\n    const data = Array(width * height).fill(null);\n\n    // Use a Set to track occupied positions for faster lookups\n    const occupiedPositions = new Set();\n    const growingPoints = [];\n\n    // Create initial crystals\n    for (let i = 0; i &lt; startCrystals; i++) {\n        let x, y, index;\n\n        // Ensure we don't place crystals on already occupied positions\n        do {\n        x = Math.floor(Math.random() * width);\n        y = Math.floor(Math.random() * height);\n        index = coordsToIndex(x, y, width);\n        } while (occupiedPositions.has(index));\n\n        const color = Math.random() * 255;\n        const crystal = { x, y, color };\n\n        data[index] = crystal;\n        occupiedPositions.add(index);\n        growingPoints.push(crystal);\n    }\n\n    return { data, occupiedPositions, growingPoints };\n}\n\n// Create direction vectors with weights\nfunction createDirections(wNegX, wNegY, wPosX, wPosY, wNegXNegY, wNegXPosY, wPosXNegY, wPosXPosY) {\n    return [\n        { dx: -1, dy: 0, w: wNegX },    // left\n        { dx: 1, dy: 0, w: wPosX },     // right\n        { dx: 0, dy: -1, w: wPosY },    // up\n        { dx: 0, dy: 1, w: wNegY },     // down\n        { dx: -1, dy: -1, w: wNegXNegY }, // top-left\n        { dx: -1, dy: 1, w: wNegXPosY },  // bottom-left\n        { dx: 1, dy: -1, w: wPosXNegY },  // top-right\n        { dx: 1, dy: 1, w: wPosXPosY }    // bottom-right\n    ];\n}\n\n// Attempt to create a new random crystal\nfunction tryCreateRandomCrystal(data, occupiedPositions, queue, width, height) {\n    for (let i = 0; i &lt; 100; i++) {\n        // Randomly select a position\n        const randomIndex = Math.floor(Math.random() * data.length);\n        if (occupiedPositions.has(randomIndex)) continue;\n\n        const { x: nX, y: nY } = indexToCoords(randomIndex, width);\n        const newCrystal = {\n        color: Math.random() * 255,\n        x: nX,\n        y: nY\n        };\n\n        // Update data structure\n        const index = coordsToIndex(nX, nY, width);\n        data[index] = newCrystal;\n        occupiedPositions.add(index);\n        queue.push(newCrystal);\n        return true;\n    }\n    return false;\n}\n\n// Process one crystal's growth\nfunction processCrystalGrowth(crystal, directions, data, occupiedPositions, queue, width, height) {\n    const { x, y, color } = crystal;\n\n    // Shuffle directions once per crystal\n    const shuffledDirs = [...directions].sort(() =&gt; Math.random() - 0.5);\n\n    let hasFound = false;\n    let hasSkipped = false;\n\n    for (const { dx, dy, w } of shuffledDirs) {\n        const nX = x + dx;\n        const nY = y + dy;\n\n        // Boundary check\n        if (nX &lt; 0 || nX &gt;= width || nY &lt; 0 || nY &gt;= height) {\n        continue;\n        }\n\n        const index = coordsToIndex(nX, nY, width);\n\n        // Check if position is already occupied\n        if (occupiedPositions.has(index)) {\n        continue;\n        }\n\n        if (Math.random() &gt; w) {\n        hasSkipped = true;\n        continue;\n        }\n\n        // Create new crystal\n        const newCrystal = { x: nX, y: nY, color };\n\n        // Update data structures\n        data[index] = newCrystal;\n        occupiedPositions.add(index);\n        queue.push(crystal);    // Add original crystal back to queue\n        queue.push(newCrystal); // Add new crystal to queue\n\n        hasFound = true;\n        break;\n    }\n\n    return { hasFound, hasSkipped };\n}\n\n// Render crystal data to canvas\nfunction renderCrystals(data, occupiedPositions, width, height) {\n    const canvas = DOM.canvas(width, height);\n    const ctx = canvas.getContext(\"2d\");\n\n    // Create image data\n    const imgData = ctx.createImageData(width, height);\n    const buffer = imgData.data;\n\n    // Fill with default color first (red for empty spaces)\n    for (let i = 0; i &lt; width * height; i++) {\n        const offset = i * 4;\n        buffer[offset] = 255;     // R\n        buffer[offset + 1] = 0;   // G\n        buffer[offset + 2] = 0;   // B\n        buffer[offset + 3] = 255; // A\n    }\n\n    // Only process occupied positions\n    for (const index of occupiedPositions) {\n        const crystal = data[index];\n        const color = crystal.color;\n        const shifted = Math.min(255, color + 10);\n\n        const offset = index * 4;\n        buffer[offset] = color;     // R\n        buffer[offset + 1] = shifted; // G\n        buffer[offset + 2] = shifted; // B\n        // Alpha already set to 255\n    }\n\n    ctx.putImageData(imgData, 0, 0);\n    return canvas;\n}\n\n// Main simulation function\nfunction crystalGrowth(wNegX, wNegY, wPosX, wPosY, wNegXNegY, wNegXPosY, wPosXNegY, wPosXPosY,\n                    startCrystals, pNewCrystal, canvasSize) {\n    // Canvas dimensions\n    const width = canvasSize;\n    const height = canvasSize;\n\n    // Initialize simulation\n    const { data, occupiedPositions, growingPoints } = initializeSimulation(width, height, startCrystals);\n\n    // Create direction vectors\n    const directions = createDirections(wNegX, wNegY, wPosX, wPosY, wNegXNegY, wNegXPosY, wPosXNegY, wPosXPosY);\n\n    // Process growing points using a queue\n    const queue = [...growingPoints];\n    growingPoints.length = 0; // Clear the original array\n\n    // Growth algorithm\n    while (queue.length &gt; 0 || data.some(crystal =&gt; crystal === null)) {\n        // Try to create a new random crystal\n        if (Math.random() &lt; pNewCrystal) {\n        if (tryCreateRandomCrystal(data, occupiedPositions, queue, width, height)) {\n            continue;\n        }\n        }\n\n        // No more crystals to grow\n        if (queue.length === 0) break;\n\n        // Get next crystal from queue\n        const crystal = queue.shift();\n\n        // Process this crystal's growth\n        const { hasFound, hasSkipped } = processCrystalGrowth(\n            crystal,\n            directions,\n            data,\n            occupiedPositions,\n            queue,\n            width,\n            height\n        );\n\n        // If we skipped some directions but didn't grow, give this crystal another chance later\n        if (!hasFound && hasSkipped) {\n        queue.push(crystal);\n        }\n    }\n\n    // Render the result\n    return renderCrystals(data, occupiedPositions, width, height);\n}\n\n// Run the simulation with the current parameter values\ncrystalGrowth(wNegX, wNegY, wPosX, wPosY, wNegXNegY, wNegXPosY, wPosXNegY, wPosXPosY,\n    startCrystals, pNewCrystal, canvasSize)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeneriertes Metall"
  },
  {
    "objectID": "runde_1/aufgabe_2/index.html#diskussion-des-ansatzes",
    "href": "runde_1/aufgabe_2/index.html#diskussion-des-ansatzes",
    "title": "2. Aufgabe: Verzinkt",
    "section": "Diskussion des Ansatzes",
    "text": "Diskussion des Ansatzes\nDie implementierte Simulation ermöglicht es, die charakteristischen Muster von feuerverzinktem Metall realistisch nachzubilden. Unser Ansatz hat folgende Eigenschaften:\n\nInteraktivität: Durch die Steuerelemente können Benutzer verschiedene Parameter anpassen und unmittelbar die Auswirkungen auf das resultierende Muster beobachten.\nEffizienz: Die Verwendung optimierter Datenstrukturen ermöglicht eine flüssige Simulation auch bei größeren Canvas-Größen.\nRealismus: Die zufällige Keimbildung und das konkurrierende Wachstum der Kristalle ahmen die natürlichen Prozesse nach, die bei der Feuerverzinkung auftreten.\n\n\nMögliche Erweiterungen\nFür eine noch realistischere Simulation könnten folgende Aspekte hinzugefügt werden:\n\nTemperaturgradienten: Simulation der Abkühlung des Metalls, die die Kristallbildung beeinflusst\nMaterialverunreinigungen: Simulation von Störstellen, die das Wachstumsmuster beeinflussen\n3D-Visualisierung: Erweiterung auf eine dreidimensionale Darstellung für noch realistischere Ergebnisse\nPhysikalisch basierte Rendering-Techniken: Verbesserte Darstellung der Lichtreflexionen an den Kristalloberflächen"
  }
]