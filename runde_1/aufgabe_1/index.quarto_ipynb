{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"1. Aufgabe: Störung\"\n",
        "format:\n",
        "  html:\n",
        "    css: \"../../styles.css\"\n",
        "    toc: true\n",
        "    toc-title: \"Inhalt\"\n",
        "---\n",
        "\n",
        "::: {.callout-note appearance=\"simple\"}\n",
        "## Die Aufgabe\n",
        "Alice und Bob tauschen in ihrem persönlichen Chat\n",
        "gerne Sätze aus, die Zitate aus ihrem Lieblingsbuch sind. Leider hat Trudi einen Weg gefunden,\n",
        "Lücken in die Sätze zu reißen und ganze Wörter\n",
        "verschwinden zu lassen. So empfing Bob vor\n",
        "Kurzem diesen Lückensatz von Alice, den er nicht\n",
        "verstehen konnte:\n",
        "\n",
        "`das ... mir ... ... ... vor`\n",
        "\n",
        "Er musste lange im Buch blättern, bis er diese\n",
        "passende Stelle darin fand:\n",
        "\n",
        "`das kommt mir gar nicht richtig vor`\n",
        "\n",
        "Aber er ist unsicher, denn schließlich könnte es ja\n",
        "noch andere passende Stellen geben.\n",
        "Alice und Bob überlegen, wie sie das Problem\n",
        "lösen können. Den Text des Lieblingsbuches gibt\n",
        "es auch digital. Da könnte es doch möglich sein,\n",
        "sich die Suche nach passenden Stellen von einem\n",
        "Computerprogramm abnehmen zu lassen.\n",
        ":::\n",
        "\n",
        "## Unser Ansatz: Textmustersuche mit Regulären Ausdrücken\n",
        "\n",
        "Das Problem, das Alice und Bob haben, ist ein klassisches Mustererkennungsproblem: Wie findet man einen Teilsatz, bei dem nur einige Wörter bekannt sind, während andere Wörter fehlen?\n",
        "\n",
        "Für die Lösung bietet sich die Verwendung von **regulären Ausdrücken** (Regular Expressions, kurz RegEx) an. Mit RegEx können wir flexible Muster definieren, die genau unserem Problem entsprechen:\n",
        "\n",
        "1. Bekannte Wörter bleiben unverändert im Suchmuster\n",
        "2. Lücken (fehlende Wörter) werden durch einen Platzhalter ersetzt, der \"irgendein Wort\" repräsentiert\n",
        "3. Die Reihenfolge der Wörter bleibt erhalten\n",
        "\n",
        "### Die Hauptschritte des Algorithmus:\n",
        "\n",
        "1. **Eingabe lesen**: Wir lesen die \"gestörten\" Sätze aus den Dateien\n",
        "2. **Muster erstellen**: Wir erstellen ein RegEx-Muster, das bekannte Wörter und Lücken enthält\n",
        "3. **Suche durchführen**: Wir durchsuchen den Text nach passenden Stellen\n",
        "4. **Ergebnisse anzeigen**: Wir zeigen die gefundenen kompletten Sätze an\n",
        "\n",
        "## Dateien"
      ],
      "id": "3ab4215a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: list-files\n",
        "#| echo: false\n",
        "#| output: asis\n",
        "\n",
        "import os\n",
        "import pathlib\n",
        "\n",
        "files_dir = pathlib.Path(\"files\")\n",
        "files = sorted(os.listdir(files_dir))\n",
        "\n",
        "for file in files:\n",
        "    file_path = files_dir / file\n",
        "    if file_path.is_file():\n",
        "        print(f\"- [{file}](files/{file})\")"
      ],
      "id": "list-files",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-tip}\n",
        "Die Dateien `stoerung0.txt` bis `stoerung5.txt` enthalten die lückenhaften Sätze, wobei `_` für ein fehlendes Wort steht. Die Datei `Alice_im_Wunderland.txt` enthält den vollständigen Text des Buches.\n",
        ":::\n",
        "\n",
        "## Implementierung der Lösung\n",
        "\n",
        "Unsere Implementierung verwendet die `re`-Bibliothek in Python, um reguläre Ausdrücke zu verarbeiten:"
      ],
      "id": "a1c3bd3e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: code-explanation\n",
        "#| code-fold: false\n",
        "#| eval: false\n",
        "\n",
        "# Regex-Muster für ein beliebiges Wort\n",
        "word_pattern = \"([a-z])\\\\w+\"\n",
        "\n",
        "# Für jede Lücke (_) verwenden wir das Wort-Muster\n",
        "# Für bekannte Wörter verwenden wir den exakten Text"
      ],
      "id": "code-explanation",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Lösung"
      ],
      "id": "5fea46ee"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: exercise-fig\n",
        "#| fig-cap: Gefundene Lösungen für die Lückensätze\n",
        "#| fig-alt: Lösungen für die Lückensätze aus Alice im Wunderland\n",
        "#| output: asis\n",
        "#| code-fold: true\n",
        "import re\n",
        "\n",
        "questions: list[str] = []\n",
        "for i in range(0, 6):\n",
        "    file_name = \"files/stoerung\" + str(i) + \".txt\"\n",
        "    f = open(file_name)\n",
        "    questions.append(f.read())\n",
        "\n",
        "base_text = open(\"files/Alice_im_Wunderland.txt\").read().lower()\n",
        "\n",
        "for i, question in enumerate(questions):\n",
        "    parts = question.split(\" \")\n",
        "    regex_parts = []\n",
        "\n",
        "    for part in parts:\n",
        "        if part == \"_\":\n",
        "            regex_parts.append(\"([a-z])\\\\w+\")\n",
        "        else:\n",
        "            regex_parts.append(part)\n",
        "\n",
        "    regex = \" \".join(regex_parts)\n",
        "\n",
        "    matches = re.search(regex, base_text, re.IGNORECASE)\n",
        "    if matches is None:\n",
        "        print(\"No match found for:\", regex)\n",
        "        continue\n",
        "\n",
        "    m = matches.group(0).split(\" \")\n",
        "    print(f\"Lösung zu Störung {i}\\n\")\n",
        "    print(f\"\\n\\n**Lückensatz:** `{question}`\\n\")\n",
        "    print(f\"**Vollständiger Satz:**\")\n",
        "\n",
        "    result = []\n",
        "    for j, part in enumerate(parts):\n",
        "        if part != \"_\":\n",
        "            result.append(part)\n",
        "        else:\n",
        "            result.append(f\"**{m[j]}**\")\n",
        "\n",
        "    print(f\"`{' '.join(result)}`\")\n",
        "    print(\"\\n\\n<br><br>\")"
      ],
      "id": "exercise-fig",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Diskussion des Ansatzes\n",
        "\n",
        "Diese Methode hat einige interessante Eigenschaften:\n",
        "\n",
        "1. **Flexibilität**: Der Ansatz funktioniert für beliebig viele Lücken in einem Satz\n",
        "2. **Effizienz**: Reguläre Ausdrücke sind für Textsuche optimiert und arbeiten sehr schnell\n",
        "3. **Grenzen**: Es kann zu falschen Treffern kommen, wenn die vorhandenen Wörter nicht eindeutig genug sind\n",
        "\n",
        "Für eine erweiterte Lösung könnte man:\n",
        "\n",
        "- Kontextinformationen berücksichtigen (z.B. Kapitel oder Abschnitte)\n",
        "- Mehrere mögliche Treffer anzeigen und bewerten\n",
        "- Sprachmodelle einsetzen, um die wahrscheinlichste Vervollständigung zu finden"
      ],
      "id": "21bc2148"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/hendrik/Documents/quarto/coding-adventures/.venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}